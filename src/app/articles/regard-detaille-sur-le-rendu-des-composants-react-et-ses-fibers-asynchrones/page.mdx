import { ArticleLayout } from '@/components/ArticleLayout'

export const article = {
	author: 'Dimitri Bourreau',
	date: '2025-09-02',
	title: 'Regard d√©taill√© sur le rendu des composants React et ses Fibers asynchrones',
	description:
		"On parlait de Virtual DOM il y a longtemps, mais est-ce toujours actuel ? Si un composant est ¬´¬†rendu¬†¬ª que se passe-t-il en m√©moire et visuellement dans le DOM ? Quelles sont les bonnes pratiques pour am√©liorer les performances li√©es aux rendus ? Est-ce que je pense que useMemo est √† √©viter ? ",
}

export const metadata = {
	title: article.title,
	description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

> Cet article est th√©orique et se destine aux devs connaissant d√©j√† les bases de React. Nous parlerons de rendu, d‚Äôhydratation et des Fibers.

On parlait de Virtual DOM il y a longtemps, mais est-ce toujours actuel ? Si un composant est ¬´ rendu ¬ª que se passe-t-il en m√©moire et visuellement dans le DOM ? Quelles sont les bonnes pratiques pour am√©liorer les performances li√©es aux rendus ? Est-ce que je pense que useMemo est √† √©viter ?

Apr√®s 6 ans √† utiliser React activement, j‚Äôai d√©cid√© de m‚Äôengager fermement √† en devenir expert. Autant vous en faire profiter !

## Le DOM virtuel, c‚Äôest encore un truc aujourd‚Äôhui ?

Oui, et c‚Äôest toujours le coeur de React !

Seulement aujourd‚Äôhui nous ne comparons plus des noeuds du DOM entre eux pour identifier les diff√©rences √† y appliquer.

C‚Äôest un peu diff√©rent maintenant gr√¢ce aux Fibers de React, des objets regroupant les donn√©es d‚Äôun composant dont une r√©f√©rence vers le noeud DOM, son input et son output !

- **Avant React 16, en 2017** React comparait les noeuds du DOM avec ceux d‚Äôun DOM virtuel, pour ensuite modifier les noeuds qui le n√©cessitaient. C‚Äôest bien, mais √ßa monopolisait le main thread, et certaines fonctionnalit√©s √©taient compliqu√©es √† impl√©menter avec cette structure.
- **Avec React 16, en 2017** React compare dor√©navant des Fibers. Il n‚Äôy avait pas d‚Äôavantage significatif en performances √† passer aux Fibers, mais la conception de nouvelles fonctionnalit√©s √©tait simplifi√©e avec cette infrastructure. Avec React 16 sont apparu les Fragment et les Portal par exemple. Surtout, les Fibers ouvraient la porte √† ce que les √©quipes de React consid√©raient √™tre le futur : une hydratation asynchrone !
- **Avec React 18, en 2022** L‚Äôhydratation est devenue asynchrone, il est devenu possible de prioriser, mettre en pause ou reprendre une hydratation ! Par exemple, si l‚Äôutilisateur compl√®te un input pendant le rendu d‚Äôun formulaire, le rendu du formulaire sera mis en pause ou arr√™t√© et le rendu de l‚Äôinput prendra la priorit√©. J‚Äôy vois deux avantages principaux : une interface plus r√©active aux actions de l‚Äôutilisateur, et une hydratation plus flexible, capable de lib√©rer le main thread.

> Je vous recommande la lecture de cet article du blog des ing√©nieurs de Facebook √† propos de la r√©√©criture du coeur de React pour impl√©menter les Fibers ! https://engineering.fb.com/2017/09/26/web/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/

## Peut-on nous-m√™me manipuler cette hydratation et la prioriser ou la mettre en pause ?

L‚Äôarriv√©e des Fibers se voulait transparente pour les devs.

On ne peut pas manuellement mettre en pause une hydratation, mais on peut indiquer ce qui n‚Äôest pas urgent √† hydrater, ce qui peut attendre la priorit√© d‚Äôun autre travail.

Concr√®tement, l‚Äôaction pass√©e en callback √† startTransition est consid√©r√©e comme non-urgente. Pendant l‚Äôex√©cution de ce callback les autres changements d‚Äô√©tat seront prioritaires. Si l‚Äôutilisateur compl√®te un input pendant l‚Äôex√©cution d‚Äôune action, le rendu de l‚Äôinput sera mis en marche sans attendre la fin de l‚Äôaction.

Mon point de vue : comme useMemo, cette fonctionnalit√© n‚Äôest √† utiliser que pour r√©pondre √† un probl√®me. Et la majorit√© du temps, ce n‚Äôest ni n√©cessaire ni utile.

## Quand est-ce que le rendu d‚Äôun composant intervient ?

Le rendu d‚Äôun composant est planifi√© :

- Lors de son affichage initial.
- Lorsqu‚Äôun de ses √©tats (state) est modifi√©.
- Le rendu est annul√© si sa nouvelle valeur correspond √† la pr√©c√©dente
- Lorsqu‚Äôun de ses props est modifi√©.
- Le rendu est annul√© si sa nouvelle valeur correspond √† la pr√©c√©dente

Je dis ¬´ planifi√© ¬ª parce que s‚Äôensuit une √©tude de la n√©cessit√© du rendu. Si ce nouveau rendu s‚Äôav√®re inutile, aucune modification n‚Äôest initialis√©e, le contenu du DOM reste tel quel.

## Si un composant est re-rendu, ces enfants le sont forc√©ment eux aussi ?

Non ! Et m√™me que depuis peu, React a optimis√© ce sujet avec son compilateur qui automatiquement am√©liore la m√©mo√Øsation de l‚Äôapplication.

Gardons le sujet du compilateur pour plus tard. Dans un premier temps, comment manuellement s‚Äôassurer que l‚Äôenfant d‚Äôun composant re-rendu ne l‚Äôest pas lui-m√™me ?

- Contenir l‚Äôenfant dans un React.memo et conserver les m√™mes props (shallow equality).
- Contenir l‚Äôenfant dans un React.memo et confier √† ce memo en deuxi√®me argument un callback retournant true.
- React.memo prend en deuxi√®me argument un callback retournant un bool√©en. Ce bool√©en indique si les props pr√©c√©dentes sont identiques aux nouvelles. En d‚Äôautres termes, retourner true ici emp√™che le nouveau rendu du composant !

> Attention : si un Context est mis √† jour et que sa valeur change, l‚Äôenfant sera rendu de nouveau !

## L‚Äôautomatisation du r√©cent React Compiler

Ce compilateur, optionnel, optimise l‚Äôapplication React au moment du build et s‚Äôattaque √† automatiser l‚Äôint√©gration de la m√©mo√Øsation. En d‚Äôautres termes, il rend inutile l‚Äôint√©gration manuelle de React.memo, useCallback et useMemo.

Donc, si on utilise ce compilateur, les rendus sont automatiquement optimis√©s !

## useMemo, oubliez !

Si j‚Äôai d√©j√† fait une revue de votre code, c‚Äôest probable que vous ayez eu droit au commentaire suivant :

> useMemo ou useCallback, je recommande vraiment de les utiliser en dernier recours. Il sont utiles lorsqu'il y a une anomalie de performance, lorsque des calculs lourds sont r√©alis√©s. Sinon, c'est une source de bug assez fr√©quente, une complexit√© sans valeur ajout√©e. M√™me la documentation officielle le dit ! ü•≤https://react.dev/reference/react/useMemo

Maintenant avec le compilateur de React, plus d‚Äôexcuses !

## Et pour finir, Next !

Next.js a une utilisation int√©ressante de React du point de vue du rendu.

Sans parler des composants rendus c√¥t√© serveur, de SSR ou de SSG, j‚Äôaimerais m‚Äôarr√™ter sur un sujet pr√©cis : le streaming.

On a vu que les Fibers permettaient d‚Äôidentifier pr√©cis√©ment des noeuds de l‚Äôinterface pour y trouver les diff√©rences √† appliquer.

Tout √ßa se passe c√¥t√© client normalement : l‚Äôhydratation ne se passe jamais c√¥t√© serveur. Autrement dit, tout se passe via du JavaScript c√¥t√© client.

Next, par d√©faut, envoie un HTML sans le JS n√©cessaire pour l‚Äôhydrater, travaille c√¥t√© serveur cette l‚Äôhydratation, puis envoie c√¥t√© client les diff√©rences √† appliquer. R√©sultat : l‚Äôutilisateur voit l‚Äôinterface plus vite et a le sentiment que le site est plus rapide et fluide.

> Note : ce n‚Äôest pas l‚Äôid√©al pour tous les cas de figure, il y a des r√©gions du monde seulement couvertes par de la 2G ou nous pr√©f√®rerons d‚Äôautres approches en optimisant le nombre de requ√™tes et la taille des bundles.

## Conclusion

React est un outil mature qui s‚Äôam√©liore continuellement.

Comme JavaScript, React permet beaucoup de choses. Pour les devs consciencieux, c‚Äôest un outil formidable facilitant le travail pour tomber juste par rapport aux besoins parfois tr√®s fins et complexes de certains projets.

C‚Äôest un plaisir de d√©couvrir cette techno jusqu‚Äôaux tr√©fonds de son code source, parce que le code est √©l√©gant, lisible, parce que la documentation est exceptionnellement agr√©able et riche et enfin parce que la communaut√© de devs est imposante et active.

## Sources

https://react.dev/learn/react-compiler
https://github.com/acdlite/react-fiber-architecture
https://legacy.reactjs.org/blog/2017/09/26/react-v16.0.html
https://react.dev/blog/2022/03/29/react-v18
https://react.dev/reference/react/startTransition

## Petite note avanc√©e : les bitmasks des Fibers, quelle bonne id√©e !

En √©tudiant le fonctionnement interne de React, j‚Äôai d√©couvert que React analysait si un objet Fiber n√©cessitait un nouveau rendu via des bitmasks. Et j‚Äôai trouv√© l‚Äôapproche tr√®s int√©ressante !

https://github.com/facebook/react/blob/8d7b5e490320732f40d9c3aa4590b5b0ae5116f5/packages/react-reconciler/src/ReactFiberLane.js#L41

Cette utilisation des bitmasks permet √† moindre co√ªt de pr√©cis√©ment d√©finir quelles t√¢ches restent √† faire, puis de les r√©aliser par ordre de priorit√©. Tout √ßa avec une seule variable, magique !
